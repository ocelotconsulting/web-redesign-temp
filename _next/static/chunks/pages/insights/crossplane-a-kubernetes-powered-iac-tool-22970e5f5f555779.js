(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[957],{5322:function(e,t){"use strict";t.DF={prefix:"fas",iconName:"calendar",icon:[448,512,[128197,128198],"f133","M96 32V64H48C21.5 64 0 85.5 0 112v48H448V112c0-26.5-21.5-48-48-48H352V32c0-17.7-14.3-32-32-32s-32 14.3-32 32V64H160V32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192H0V464c0 26.5 21.5 48 48 48H400c26.5 0 48-21.5 48-48V192z"]},t.fT=t.DF},4691:function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a="circle-user",o=[62142,"user-circle"],s="f2bd",r="M399 384.2C376.9 345.8 335.4 320 288 320H224c-47.4 0-88.9 25.8-111 64.2c35.2 39.2 86.2 63.8 143 63.8s107.8-24.7 143-63.8zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zm256 16a72 72 0 1 0 0-144 72 72 0 1 0 0 144z";t.definition={prefix:"fas",iconName:a,icon:[512,512,o,s,r]},t.faCircleUser=t.definition,t.prefix="fas",t.iconName=a,t.width=512,t.height=512,t.ligatures=o,t.unicode=s,t.svgPathData=r,t.aliases=o},6529:function(e,t,a){"use strict";var o=a(4691);t.DF={prefix:o.prefix,iconName:o.iconName,icon:[o.width,o.height,o.aliases,o.unicode,o.svgPathData]},t.m0=t.DF,o.prefix,o.iconName,o.width,o.height,o.aliases,o.unicode,o.svgPathData,o.aliases},598:function(e,t,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/insights/crossplane-a-kubernetes-powered-iac-tool",function(){return a(8301)}])},5802:function(e,t,a){"use strict";a.d(t,{Z:function(){return s}});var o=a(5893);function s(e){let{children:t,className:a="",containerClassName:s="",backLayer:r="",frontLayer:n="",fullWidth:i=!1,...c}=e;return(0,o.jsxs)("section",{className:"relative py-14 md:py-20 px-5 ".concat(a),...c,children:[r,(0,o.jsx)("div",{className:"relative ".concat(i?"":"container mx-auto"," ").concat(s),children:t}),n]})}},378:function(e,t,a){"use strict";a.d(t,{Z:function(){return c}});var o=a(5893),s=a(5802),r=a(2489),n=a(5322),i=a(6529);function c(e){let{title:t,image:a,date:c,author:l,children:h}=e;return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(s.Z,{style:{backgroundImage:"url(/insights/".concat(a,")")},className:"bg-cover bg-center md:min-h-[370px] flex flex-col justify-center",backLayer:(0,o.jsx)("div",{className:"absolute inset-0 bg-black/40"}),children:[(0,o.jsx)("h1",{className:"text-4xl md:text-7xl font-bold text-white md:text-left text-center",children:t}),(0,o.jsxs)("p",{className:"text-white",children:[(0,o.jsx)(r.G,{className:"text-accent mr-2",icon:n.fT}),c]}),(0,o.jsxs)("p",{className:"text-white",children:[(0,o.jsx)(r.G,{className:"text-accent mr-2",icon:i.m0}),"By ",l]})]}),(0,o.jsx)(s.Z,{children:h})]})}},8301:function(e,t,a){"use strict";a.r(t),a.d(t,{default:function(){return r}});var o=a(5893),s=a(378);function r(){return(0,o.jsx)(s.Z,{title:"Crossplane, a Kubernetes-powered IAC Tool",image:"taylor-heery-MozHFKIq4ek-unsplash-2048x1365.jpg",date:"August 8, 2022",author:"Khuyen Tran",children:'[Crossplane](https://crossplane.io/) is a newer member of the Infrastructure-as-Code team, with many components still yet to be built or in an alpha or beta state. Although it is new, it introduces some novel ideas of how to manage infrastructure that you deploy, especially if you are familiar with Kubernetes ## Where’s the demo? Here’s my [example code](https://gitlab.com/mjh/crossplane-demo/), but don’t get too excited before the explanation. ## Back up, what is Infrastructure as Code? Imagine if you have a smart thermostat in your house and you set it to a pleasant 68 degrees. The thermostat then regularly takes the temperature of the house and heats or cools it as appropriate. This concept is called state and it means that you want it at 68 degrees as a state and you want the thermostat to keep it at that state. You might also want the thermostat to do different things depending on time of day. Maybe you go to your weekend board game day at your friend’s every Saturday, and it’s okay for it to get up to 74 degrees on Saturday during the day in the summer or down to 62 degrees in the winter. This is a new state that gets passed to it on Saturdays and then it gets sent the regular, 68 degree state otherwise. During this time you expect the degree you set it to is what the thermostat is going to hit. What if you run something even bigger though? Imagine you run a museum where parts that the tourists are going through can be 72 degrees, but you have several sections with glass that need to be kept colder for preservation, perhaps at 55 degrees, and several more sections that your employees take breaks in or do office work at, and you keep that at 68 degrees. This can mean you have a hundred thermostats that have a state assigned to them. If an exhibit changes and no longer needs to be 55 degrees, you probably want it at the 72 degrees of everything else. If you add a new exhibit, you need to add a new thermostat at whatever the appropriate temperature is. But here you are, 100 thermostats all set nicely. Then you lose power. Panicked you probably start taking care of secure pieces, escorting visitors out, and generally managing the function of the museum. You safely secure the place and several hours later, the power comes back. However, while power was out, it wiped the memory of those thermostats – and now they’re all holding at 74 degrees. So, you need to hurry up and get them, especially the preservation temperatures, all back. What can you do? That’s right, your poor volunteers staff and interns are running around to 100 different thermostats and setting them to the notes you made next to them – and hopefully those sticky notes are still accurate! Imagine if, instead of several people running around, setting thermostats, hoping they’re correct, double checking them, and making alterations, you could just push a button and they’d go back to what you initially set them. That’s what infrastructure-as-code is about – keeping your configuration, temperatures in this case, stored in code so that you can deploy or redeploy them as necessary. You also don’t need to worry about keeping sticky notes or manual intervention – you just update the code and deploy it. There are many tools to work with infrastructure-as-code and they work each in their own way. Common ones you’ll see are: - [Terraform](https://www.ocelotconsulting.com/2022/08/08/terraform.io) - [AWS CloudFormation](https://aws.amazon.com/cloudformation/) – specifically for AWS resources - [Azure Resource Manager](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/overview) – specifically for Azure resources - [Pulumi](https://www.pulumi.com/) But I want to talk about a specific one of these – [Crossplane](https://www.ocelotconsulting.com/2022/08/08/crossplane.io). ## What is Crossplane? Crossplane is an infrastructure-as-code tool that manages your infrastructure as Kubernetes objects and keeps state within Kubernetes, leveraging controllers and extensions for various cloud providers and their object types. What does this mean? If you’re use to something such as Terraform, you have .tf files that explain what the code should do. You can import modules, import InsightLayout from "@/components/insights/InsightLayout"; use existing providers, and everything. In my demo, I actually have the [terraform](https://gitlab.com/mjh/crossplane-demo/-/tree/main/terraform) I used to build the Kubernetes cluster I did my examples with. In it, you can see I have two files – main.tf and k8s.tf main.tf defines my provider (DigitalOcean), grabs the API token from my local machine, and defines which version of Terraform to use. k8s.tf defines what should actually be built – in this case, a scalable Kubernetes cluster using a smaller Droplet for my workers. I deploy those two files and there you have a Kubernetes cluster (Terraform state is for another discussion, but I do have a solution there). If you want to run that code, and have an API key handy, you could run it from that directory and get a Kubernetes cluster (something like terraform apply -var “do_token=$DO_TOKEN”). So, what makes Crossplane different? Crossplane sees the providers and their configurations as extensions of Kubernetes. After [installing Crossplane into your cluster](https://crossplane.io/docs/v1.9/getting-started/install-configure.html#install-crossplane) with helm, you have a whole set of new Kubernetes Objects you can work with. The biggest being Provider and ProviderConfig. By using both of these, you can get the ability to create your infrastructure as Kubernetes objects, using yaml to write them and Kubernetes to check and maintain state. ## Okay, let’s do this! My [demo repo](https://gitlab.com/mjh/crossplane-demo/-/tree/main/crossplane_install) has three different providers, DigitalOcean, AWS, and Azure. Each of these will reach out to a different repository and grab new Objects that can be managed. As of 28 Jul, they are the latest versions, but I can’t promise to maintain that – you can check the versions at the github repos for the Crossplane Contribs for [Azure](https://github.com/crossplane-contrib/provider-azure), [AWS](https://github.com/crossplane-contrib/provider-aws), and [DigitalOcean](https://github.com/crossplane-contrib/provider-digitalocean/) or any of the other providers Crossplane has in [one nice spot](https://crossplane.io/docs/v1.9/concepts/providers.html). For instance, applying the [azure-install.yaml](https://gitlab.com/mjh/crossplane-demo/-/blob/main/crossplane_install/azure_install.yaml) will allow access to all the Azure objects as the provider provider-azure. You can even see all your providers at a quick glance with normal kubectl commands. Which brings me to the ProviderConfig object. This is how you reference your user that has permissions to deploy. This user will need pretty broad permissions in order to deploy anything and should be a closely held secret. However, once the configuration is in Kubernetes, there’s no need to keep pulling it down or risk having more people have it. This is one of the things I like about how Crossplane does Providers and ProviderConfigs. Each ProviderConfig has a slightly different way of presenting credentials and this is something that Crossplane has room for improvement on. For instance, to get the AWS Credentials, assuming you have credentials locally and in the default profile, you run a little script: BASE64ENCODED_AWS_ACCOUNT_CREDS=$(echo -e "[default]\\naws_access_key_id = $(aws configure get aws_access_key_id --profile $aws_profile)\\naws_secret_access_key = $(aws configure get aws_secret_access_key --profile $aws_profile)" | base64  | tr -d "\\n") And this will get you the encoded credentials you’d put in the ProviderConfiguration for AWS [here](https://gitlab.com/mjh/crossplane-demo/-/blob/main/crossplane_configure/aws_configure.yaml#L9), where it says replacewithbase64encoded. ` --- apiVersion: v1 kind: Secret metadata: name: aws-account-creds namespace: crossplane-system type: Opaque data: credentials: replacewithbase64encoded --- apiVersion: aws.crossplane.io/v1beta1 kind: ProviderConfig metadata: name: provider-aws spec: credentials: source: Secret secretRef: namespace: crossplane-system name: aws-account-creds key: credentials ` Alrighty! Now that we have a provider configured with AWS Secrets…what do we do? We write some YAML! I promise, I will break this down, but let’s make a hosted S3 bucket website. The yaml is in my [demo repo](https://gitlab.com/mjh/crossplane-demo/-/blob/main/crossplane/site_s3.yaml) but let’s break down the big pieces. ` --- apiVersion: s3.aws.crossplane.io/v1beta1 kind: Bucket metadata: name: s3-crossplane-bucket annotations: # This will be the actual bucket name. It must be globally unique, so you # probably want to change it before trying to apply this example. crossplane.io/external-name: crossplane-nalth-is ` So you can see in this part we are creating a Kubernetes Object with a kind of Bucket off the s3.aws.crossplane.io/v1beta1extension we’ve installed. In it, we give the bucket an internal facting name in metadata and an external name in the crossplane.io/external-name part of the annotations. This is the core of what the object will be. ` spec: forProvider: acl: private locationConstraint: us-east-1 websiteConfiguration: indexDocument: suffix: index.html publicAccessBlockConfiguration: blockPublicPolicy: false accelerateConfiguration: status: Suspended versioningConfiguration: status: Suspended tagging: tagSet: - key: project value: blog objectLockEnabledForBucket: false serverSideEncryptionConfiguration: rules: - applyServerSideEncryptionByDefault: sseAlgorithm: AES256 corsConfiguration: corsRules: - allowedMethods: - "GET" allowedOrigins: - "*" allowedHeaders: - "*" exposeHeaders: - "x-amz-server-side-encryption" lifecycleConfiguration: rules: - status: Disabled ` This in here are the things you want your bucket to have and do, normal things like tagging, versioning, and where your default page is for your site (in a static website hosted S3 bucket). S3 has a lot of options that I won’t cover in this blog, but suffice it to say that these are just checkmarks in the console of AWS or properties in Terraform. ` providerConfigRef: name: provider-aws `'})}}},function(e){e.O(0,[774,888,179],function(){return e(e.s=598)}),_N_E=e.O()}]);